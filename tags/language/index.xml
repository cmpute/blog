<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Language | JacobZ</title><link>https://zyxin.xyz/blog/tags/language/</link><description>JacobZ的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>cmpute@foxmail.com (Jacob Zhong)</managingEditor><webMaster>cmpute@foxmail.com (Jacob Zhong)</webMaster><lastBuildDate>Sun, 24 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://zyxin.xyz/blog/tags/language/index.xml" rel="self" type="application/rss+xml"/><item><title>（C语言）变长数组的陷阱</title><link>https://zyxin.xyz/blog/2022-07/the-pitfall-of-vla/</link><pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2022-07/the-pitfall-of-vla/</guid><description>&lt;div class="article-notice active-class note">
&lt;div class="article-notice-title">
&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
&lt;path stroke="none" d="M0 0h24v24H0z" fill="none"/>
&lt;path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
&lt;line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
&lt;/svg>
&lt;span>前言&lt;/span>
&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-right" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
&lt;path stroke="none" d="M0 0h24v24H0z" fill="none"/>
&lt;polyline points="9 6 15 12 9 18" />
&lt;/svg>
&lt;/div>
&lt;div class="article-notice-body" >
&lt;section>
这篇文章转载自&lt;a class="link" href="https://blog.joren.ga/vla-pitfalls" target="_blank" rel="noopener"
>Jorengarenar的博客&lt;/a>。类似于前一篇文章，这一篇博文是我在搜索为什么Rust不支持动态栈分配的时候看到的。有很多人希望Rust支持变长数组，并且有一个&lt;a class="link" href="https://github.com/rust-lang/rust/issues/48055" target="_blank" rel="noopener"
>相关的RFC&lt;/a>，但是&lt;a class="link" href="https://users.rust-lang.org/t/a-question-about-how-memory-is-stored-and-vlas/33901/16?u=cmpute" target="_blank" rel="noopener"
>也有人提到这很危险&lt;/a>，并且不会带来太大的收益，这篇文章总结了变长数组的问题，可供参考。
&lt;/section>
&lt;/div>
&lt;/div>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2022-07/the-pitfall-of-vla/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>长浮点数（long double）的陷阱</title><link>https://zyxin.xyz/blog/2022-07/the-pitfall-of-long-double/</link><pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2022-07/the-pitfall-of-long-double/</guid><description>&lt;div class="article-notice active-class note">
&lt;div class="article-notice-title">
&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-pencil" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
&lt;path stroke="none" d="M0 0h24v24H0z" fill="none"/>
&lt;path d="M4 20h4l10.5 -10.5a1.5 1.5 0 0 0 -4 -4l-10.5 10.5v4" />
&lt;line x1="13.5" y1="6.5" x2="17.5" y2="10.5" />
&lt;/svg>
&lt;span>前言&lt;/span>
&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-right" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
&lt;path stroke="none" d="M0 0h24v24H0z" fill="none"/>
&lt;polyline points="9 6 15 12 9 18" />
&lt;/svg>
&lt;/div>
&lt;div class="article-notice-body" >
&lt;section>
&lt;p>此文转载自Prelert的博客，作者为David。这篇文章目前只能&lt;a class="link" href="https://web.archive.org/web/20170422155137/http://info.prelert.com/blog/author/david" target="_blank" rel="noopener"
>在WebArchive找到&lt;/a>了，因此我把此文转载并翻译到我的博客上。&lt;/p>
&lt;p>我是在搜索为什么Rust没有对应C/C++中&lt;code>long double&lt;/code>的数据类型的时候看到了这篇博文，Rust不提供对应的数据类型造成了一些互操作性的问题（参见&lt;a class="link" href="https://immunant.com/blog/2019/11/rust2020/#:~:text=long%20doubletypes%20in%20C%20are%20specified%20as%20being,with%20C%20code%2C%20Rust%20needs%20to%20support%20long" target="_blank" rel="noopener"
>这里&lt;/a>和&lt;a class="link" href="https://github.com/rust-lang/rust-bindgen/issues/1549" target="_blank" rel="noopener"
>这里&lt;/a>）。与此相对的是，Zig和新发布的Carbon语言都支持&lt;code>f16&lt;/code>和&lt;code>f128&lt;/code>数据类型（其中Zig还支持&lt;code>f80&lt;/code>，Carbon还支持&lt;code>bfloat16&lt;/code>）。不过这倒是不令人意外，因为Zig和Carbon都以与C/C++的极致兼容性为卖点。这篇博客也许能解释一部分Rust不支持更高精度浮点数的原因。&lt;/p>
&lt;/section>
&lt;/div>
&lt;/div>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2022-07/the-pitfall-of-long-double/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>初识Rust - 从一个Python/C++/C#程序员的角度对比Rust</title><link>https://zyxin.xyz/blog/2021-10/first-glance-on-rust/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2021-10/first-glance-on-rust/</guid><description>&lt;p>近些年一直有听闻Rust的发展，相比其他新语言（如julia），我觉得Rust是切实解决了一些程序开发的痛点的，并且Rust比较适合作为底层软件开发的语言，我很感兴趣。Rust官方有一本&lt;a class="link" href="https://doc.rust-lang.org/stable/book/" target="_blank" rel="noopener"
>Gitbook教程&lt;/a>，因此我就直接通过阅读它来上手Rust了。&lt;/p>
&lt;p>本文记录一些我在看完这本书之后初步总结的一些Rust与我熟悉的Python/C++/C#之间的各方面的异同。如果你也有Python/C++/C#的编程经验，并且想上手Rust，那么这篇文章应该能帮助你概括性地了解Rust的特性。本文也是我对Python/C++/C#之间特性的一个对比总结，但是我对这些语言的了解也没有那么深，因此如有谬误还请指教。&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2021-10/first-glance-on-rust/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>一句话选择现代编程语言</title><link>https://zyxin.xyz/blog/2021-08/one-line-per-program-lang/</link><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2021-08/one-line-per-program-lang/</guid><description>&lt;p>最近几年一直有新的编程语言变火，也不断的有新概念的出现。我一直有打算了解各种新的编程语言，并且如果有前景的话多学一门语言也是挺好的。因此本文总结我在了解一些流行的现代语言的过程中，记下来他们的各种特点。如果你也有兴趣尝试新的语言，那么希望这个文章可以帮到你~&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2021-08/one-line-per-program-lang/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>进程、线程与协程 (C# vs Python)</title><link>https://zyxin.xyz/blog/2019-11/parallelism-in-python-and-csharp/</link><pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2019-11/parallelism-in-python-and-csharp/</guid><description>&lt;p>近来由于项目需要，接触了一下一直没去了解过的Python异步语法，发现和之前我熟悉的C#有很多不同。在深入Python的异步逻辑之后，由于Python在语法上保留了很多语言机制的细节（比如成员函数的&lt;code>self&lt;/code>参数），我反而对C#的异步有了更深的了解。这里就来重新梳理一下各种并行方法的区别，以及他们在C#和Python上实现的区别。（这里只讨论单机的并行机制。）&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2019-11/parallelism-in-python-and-csharp/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>Cython中的特殊函数</title><link>https://zyxin.xyz/blog/2019-08/cython-functions/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2019-08/cython-functions/</guid><description>&lt;p>这次来介绍一下Cython中的特殊函数定义，Cython相比Python本身的特殊函数之外还增加了一些新的函数，用来满足对C特性的支持，其中有些内容还经常令人混淆。关于Python中特殊变量和特殊函数名的内容，&lt;a class="link" href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener"
>请参考Python官方文档&lt;/a>。&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2019-08/cython-functions/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>在Cython中操作数组</title><link>https://zyxin.xyz/blog/2019-08/cython-array/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2019-08/cython-array/</guid><description>&lt;p>Cython提供了很多方法来搭建C/C++内存和Python对象间的桥梁，但是官方的教程只介绍了一些基础的方法。这篇文章就介绍一下我在各个场合学到和用到的Cython封装（多维）数组的技巧。一般而言这个桥梁会分为两部分，Python与Cython和Cython与C/C++。其中Python中的数组主要形式是&lt;code>list&lt;/code>、&lt;code>array.array&lt;/code>和&lt;code>numpy.ndarray&lt;/code>；Cython中的数组形式有&lt;code>[:,:,:]&lt;/code>（&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html?highlight=pointer#view-cython-arrays" target="_blank" rel="noopener"
>Memoryview&lt;/a>/&lt;a class="link" href="https://www.python.org/dev/peps/pep-3118/" target="_blank" rel="noopener"
>Buffer&lt;/a>）和&lt;code>cython.view.array&lt;/code>；C/C++的数组形式有&lt;code>**&lt;/code>（指针）、&lt;code>vector&lt;/code>和&lt;code>Eigen::Vector/Matrix&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>本篇介绍的主要内容也来自于Cython的文档：&lt;a class="link" href="http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html" target="_blank" rel="noopener"
>Typed Memoryviews&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2019-08/cython-array/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>Cython与C/C++的交互</title><link>https://zyxin.xyz/blog/2019-08/cython-interop/</link><pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2019-08/cython-interop/</guid><description>&lt;p>用Cython也用了很有一段时间了，这次就介绍一下它的最重要功能——使用Cython来封装C/C++代码。最基本的封装方法可以参见Cython文档中的相关页面：&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html" target="_blank" rel="noopener"
>Interfacing with External C Code&lt;/a>和&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html" target="_blank" rel="noopener"
>Using C++ in Cython&lt;/a>，本文介绍主要是比较重要和常用的Cython/C++交互特性，而自定义Python拓展类（而不是封装现有C++）的一些操作可以&lt;a class="link" href="https://cython.readthedocs.io/en/latest/src/tutorial/cdef_classes.html" target="_blank" rel="noopener"
>参考官方教程&lt;/a>。&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2019-08/cython-interop/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>如何选择Python与C++之间的胶水</title><link>https://zyxin.xyz/blog/2019-08/glue-python-cpp/</link><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2019-08/glue-python-cpp/</guid><description>&lt;p>Python作为一门胶水语言，它与C/C++之间的兼容性（Interoperability）我认为是它相比其他动态语言脱颖而出的最大原因。Python原生支持的是与C语言的接口，Python的发行版自带有&lt;code>Python.h&lt;/code>头文件，里面提供了在C中调用Python和反过来在Python中调用C的接口定义。但是C++就不一样了，虽然C++ ⇔ C ⇔ Python的通道是可行的，但是想要完整兼容C++的特性的话需要很多额外的重复代码（boilerplate）。因此相应针对Python/C++绑定的库也就应运而生了，我所了解的库主要有四个：&lt;a class="link" href="https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html" target="_blank" rel="noopener"
>Boost.Python&lt;/a>，&lt;a class="link" href="https://cython.org/" target="_blank" rel="noopener"
>Cython&lt;/a>，&lt;a class="link" href="https://pybind11.readthedocs.io/en/stable/" target="_blank" rel="noopener"
>pybind11&lt;/a>，&lt;a class="link" href="http://www.swig.org/" target="_blank" rel="noopener"
>SWIG&lt;/a>。虽然网上也有不少比较三者的页面，但是我觉得都不够详细，这篇博客就介绍一下我基于使用这几个库的经验比较。&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2019-08/glue-python-cpp/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>Cython中的类型系统</title><link>https://zyxin.xyz/blog/2018-12/cython-types/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2018-12/cython-types/</guid><description>&lt;p>由于最近的几个项目都有接触到Cython的使用，也积累了一些Cython的经验，于是决定把&lt;img src="https://zyxin.xyz/blog/blog/https://zyxin.xyz/blog/2017-12/cython-intro/"
loading="lazy"
alt="上次的介绍"
>续上（蜜汁发现刚好过了一年。。），将Cython的一些用法记录下来。这一些文章可以作为一些学习的参考，不过kick-start的话还是去看看&lt;a class="link" href="https://zyxin.xyz/blog/2017-12/cython-intro/" >之前的博文&lt;/a>以及&lt;a class="link" href="http://docs.cython.org/en/latest/src/quickstart/index.html" target="_blank" rel="noopener"
>官方的例子&lt;/a>吧~&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2018-12/cython-types/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>PowerShell快速上手（针对有C#经验者）</title><link>https://zyxin.xyz/blog/2018-11/powershell-for-csharp-programmer/</link><pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2018-11/powershell-for-csharp-programmer/</guid><description>&lt;p>PowerShell是微软一个非常棒的产品，终于改变了人们对Windows下命令行的一片鄙视。一直以来都很想学学PowerShell，这样我就不用使用Python作为手边的脚本语言了，对进行一些文件操作、系统操作而言PowerShell还是要比Python来的方便。另外由于有不少C#的经验，因此PowerShell能够调用.NET库的特性也能够充分利用起来，并且实际发现C#的经验让我学习PowerShell快了不少（当然使用bash、CMake这些脚本的经验应该也帮上忙了吧）。本文就是一篇针对有C#经验的用户的PowerShell上手教程，当然如果你有F#、IronPython等基于.NET的脚本经验那就更好了。&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2018-11/powershell-for-csharp-programmer/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>Python - 如何调用系统命令或外部程序</title><link>https://zyxin.xyz/blog/2017-12/python-call/</link><pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2017-12/python-call/</guid><description>&lt;p>我经常会碰到拿别人的代码过来用却发现不是Python写的代码的情况。这个时候，如果你想调用他的代码，要么自己费力地把他的和自己的代码翻译成同一种语言，要么利用语言特性直接调用（如Lua直接调用C函数），但其实最简便的办法是通过外部程序调用的方式调用他的程序，只要传入相关参数即可~本文就讲一下在Python下调用外部函数或者命令的几种方法~&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2017-12/python-call/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>Cython - 入门简介</title><link>https://zyxin.xyz/blog/2017-12/cython-intro/</link><pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2017-12/cython-intro/</guid><description>Python &amp;amp; C/C++ 近来用Python用的越来越多，对这种十分灵活的动态语言的哲学也有了较深的理解。虽然Python有不少缺点，如没有强类型，GIL全局锁
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2017-12/cython-intro/">网页&lt;/a>以阅读全文。&lt;/em></description></item><item><title>C/C++中的特殊宏</title><link>https://zyxin.xyz/blog/2017-09/special-macros-in-cpp/</link><pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate><author>cmpute@foxmail.com (Jacob Zhong)</author><guid>https://zyxin.xyz/blog/2017-09/special-macros-in-cpp/</guid><description>&lt;p>在阅读VTK和QT的源码时，遇到了类似于Python中特殊变量形式的宏，如&lt;code>__LINE__&lt;/code>和&lt;code>__FILE__&lt;/code>，这两个宏的用途是作为函数参数返回调用行数和文件名。一时惊奇，原来C里面也有这个内置宏，而且貌似在各大库的Debug模块中都经常被用到。此外也碰到了变长的宏的用法，于是查了一下标准中对宏的描述，做一下笔记，对宏代码很有帮助~&lt;/p>
&lt;hr/>&lt;em>前往&lt;a href="https://zyxin.xyz/blog/2017-09/special-macros-in-cpp/">网页&lt;/a>以阅读全文。&lt;/em></description></item></channel></rss>